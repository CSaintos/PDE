local ls = require("luasnip")
local s = ls.snippet
-- local sn = ls.snippet_node
-- local isn = ls.indent_snippet_node
local t = ls.text_node
local i = ls.insert_node

ls.add_snippets("make", {
  s("make_vars",{
    t"# ", i(1),
    t{"",
      "",
      "#? Variables",
      "# STATICLIB, DYNAMICLIB, or EXE # (no space after)",
      "BUILDTYPE = "}, i(2),
    t{"",
      "# COMPILEONLY, LINKONLY, or BOTH # (no space after)",
      "PROCESS = "}, i(3),
    t{"",
      "TARGET_NAME = "}, i(4),
    t{"",
      "# <path-to-dir>",
      "TARGET_PATH = "}, i(5),
    t{"",
      "# Include Directories # -I<path-to-dir>",
      "INCLUDES = \\"}, i(6),
    t{"",
      "# Link Directories # -L<path-to-dir>",
      "LINKDIRS = \\"}, i(7),
    t{"",
      "# if on linux or windows, for linking libraries `-l<file>` do not prepend `lib` to the link flag (unless its in the file name) as each `-l` is converted into `-l:` in maker.mk",
      "# if on osx, use -l (internal lib) syntax only, every lib file must begin with `lib`. if lib is static, it must end in `.a`, else if lib dynamic, it must end in `.dylib`",
      "# Dynamic link files # (for internal libs) `-l<file-no-extension>` or (for external libs) `-l:<file-w-extension>` # Order from most dependent to least dependent.",
      "DLINKS = \\"}, i(8),
    t{"",
      "# Static link files # (for internal libs) `-l<file-no-extension>` or (for external libs) `-l:<file-w-extension>` # Order from most dependent to least dependent.",
      "SLINKS = \\"}, i(9),
    t{"",
      "DEFINES = "}, i(9),
    t{"",
      "SRCDIRS = \\"}, i(10),
    t{"",
      "SRCFILES = \\"}, i(11),
    t{"",
      "",
      "#? Constants",
      "OBJDIR = bin/$(TARGET_PATH)",
      "TARGETDIR = build/$(TARGET_PATH)",
      "OBJCLEANDIR = $(OBJDIR)",
      "TARGETCLEANDIR = $(TARGETDIR)"},
    t{"",
      "",
      "#? Custom build cmds",
      "define POSTBUILDCMDS",
      "endef",
      "",
      "include ./make/maker.mk"},
  }),
  s("make_maker",{
    t{
      "# maker.mk",
      ".PHONY: all compile build dirs clean",
      "",
      "#* Make functions",
      "# eq uses makefile substitution reference",
      "define eq",
      "$(if $(1:$(2)=),,$(if $(2:$(1)=),,T))",
      "endef",
      "",
      "#* Compiler flags",
      "CXXFLAGS += -MMD -g",
      "ifeq ($(SYS), Windows)",
      "SLINK_TYPE = lib",
      "DLINK_TYPE = dll",
      "EXE_TYPE = .exe",
      "STATIC_LINK_FLAG=-Wl,-Bstatic",
      "DYNAMIC_LINK_FLAG=-Wl,-Bdynamic",
      "AS_NEED_LINK_FLAG=-Wl,--as-needed",
      "else ifeq ($(SYS), Linux)",
      "SLINK_TYPE = a",
      "DLINK_TYPE = so",
      "EXE_TYPE =",
      "STATIC_LINK_FLAG=-Wl,-Bstatic",
      "DYNAMIC_LINK_FLAG=-Wl,-Bdynamic",
      "AS_NEED_LINK_FLAG=-Wl,--as-needed",
      "RPATH_LINK_FLAG=-Wl,-rpath,$$ORIGIN",
      "else ifeq ($(SYS), OSX)",
      "SLINK_TYPE = a",
      "DLINK_TYPE = dylib",
      "EXE_TYPE =",
      "STATIC_LINK_FLAG=",
      "DYNAMIC_LINK_FLAG=",
      "ASNEED_LINK_FLAG=",
      "RPATH_LINK_FLAG=-Wl,-rpath,@executable_path",
      "endif",
      "ifeq ($(filter-out Windows Linux, $(SYS)),)",
      "SLINK_FILES := $(patsubst -l%, %.$(SLINK_TYPE), $(patsubst -l:%, %, $(SLINKS)))",
      "DLINK_FILES := $(patsubst -l%, %.$(DLINK_TYPE), $(patsubst -l:%, %, $(DLINKS)))",
      "SLINKS = $(patsubst %, -l:%, $(SLINK_FILES))",
      "DLINKS = $(patsubst %, -l:%, $(DLINK_FILES))",
      "else",
      "SLINK_FILES := $(patsubst -l%, lib%.$(SLINK_TYPE), $(patsubst -l:%, %, $(SLINKS)))",
      "DLINK_FILES := $(patsubst -l%, lib%.$(DLINK_TYPE), $(patsubst -l:%, %, $(DLINKS)))",
      "SLINKS = $(patsubst lib%.$(SLINK_TYPE), -l%, $(SLINK_FILES))",
      "DLINKS = $(patsubst lib%.$(DLINK_TYPE), -l%, $(DLINK_FILES))",
      "endif",
      "",
      "#* First class functions",
      "find_file = $(wildcard $(addprefix $(addsuffix /, $2), $1))",
      "compile_exe_cmd = $(CXX) -o $2 -c $1 $(INCLUDES) $(CXXFLAGS) -MF $(2:%.o=%.d)",
      "compile_lib_cmd = $(CXX) -o $2 -c $1 $(INCLUDES) -fPIC $(CXXFLAGS) -MF $(2:%.o=%.d)",
      "ifeq ($(FILESYS), Windows)",
      "cp = copy $(subst /,\\,$1) $(subst /,\\$2)",
      "else ifeq ($(filter-out Linux OSX, $(FILESYS)),)",
      "cp = cp $1 $2",
      "endif",
      "",
      "#* Constants",
      "vpath %.cpp $(SRCDIRS)",
      "DLIBS = $(foreach LINKDIR, $(patsubst -L%, %, $(LINKDIRS)), $(call find_file, $(DLINK_FILES), $(LINKDIR)))",
      "SLIBS = $(foreach LINKDIR, $(patsubst -L%, % $(LINKDIRS)), $(call find_file, $(SLINK_FILES), $(LINKDIR)))",
      "OUT_DLIBS = $(foreach DLINK_FILE, $(DLINK_FILES), $(TARGETDIR)/$(DLINK_FILE))",
      "vpath %.$(DLINK_TYPE) $(patsubst -L%, %, $(LINKDIRS))",
      "OBJECTS = $(addprefix $(OBJDIR)/, $(patsubst %.cpp, %.o, $(SRCFILES)))",
      "ifneq ($(and $(call eq,$(SYS),OSX), $(call eq,$(filter-out STATICLIB DYNAMICLIB, $(BUILDTYPE)),)),)",
      "TARGET = $(TARGETDIR/lib$(TARGET_NAME))",
      "else",
      "TARGET = $(TARGETDIR)/$(TARGET_NAME)",
      "endif",
      "ifeq ($(BUILDTYPE), EXE)",
      "TARGET := $(TARGET)$(EXE_TYPE)",
      "else ifeq ($(BUILDTYPE), STATICLIB)",
      "TARGET := $(TARGET).$(SLINK_TYPE)",
      "else ifeq ($(BUILDTYPE), DYNAMICLIB)",
      "TARGET := $(TARGET).$(DLINK_TYPE)",
      "endif",
      "",
      "#* Process execution",
      "ifeq ($(filter-out BOTH LINKONLY, $(PROCESS)),)",
      "all: $(TARGET)",
      "\t$(POSTBUILDCMDS)",
      "else ifeq ($(PROCESS), COMPILEONLY)",
      "all: $(OBJECTS)",
      "else",
      "all:",
      "\t@echo error: invalid process",
      "endif",
      "",
      "# Create bin directory",
      "$(OBJDIR):",
      "ifeq ($(wildcard $(OBJDIR)),)",
      "ifeq ($(FILESYS),Windows)",
      "\tmkdir $(subst /,\\,$(OBJDIR))",
      "else ifeq ($(filter-out Linux OSX, $(FILESYS)),)",
      "\tmkdir -p $(OBJDIR)",
      "endif",
      "endif",
      "",
      "# Compile sources into objects",
      "$(OBJECTS): $(OBJDIR)/%.o : %.cpp | $(OBJDIR)",
      "ifeq ($(BUILDTYPE), EXE)",
      "\t$(call compile_exe_cmd, $<, $@)",
      "else ifeq ($(filter-out STATICLIB DYNAMICLIB, $(BUILDTYPE)),)",
      "\t$(call compile_lib_cmd, $<, $@)",
      "else",
      "\t@echo invalid buildtype",
      "endif",
      "",
      "# Create build directory",
      "$(TARGETDIR):",
      "ifeq ($(wildcard $(TARGETDIR)),)",
      "ifeq ($(FILESYS),Windows)",
      "\tmkdir $(subst /,\\,$(TARGETDIR))",
      "else ifeq ($(filter-out Linux OSX, $(FILESYS)),)",
      "\tmkdir -p $(TARGETDIR)",
      "endif",
      "endif",
      "",
      "# More Link Flags",
      "ifeq ($(SYS),OSX)",
      "INSTALL_NAME_FLAG=-Wl,-install_name,@rpath/$(TARGET)",
      "endif",
      "",
      "# Build target from objects",
      "ifeq ($(PROCESS), LINKONLY)",
      "$(TARGET): $(SLIBS) | $(TARGETDIR) $(DLIBS)",
      "else",
      "$(TARGET): $(OBJECTS) $(SLIBS) | $(TARGETDIR) $(DLIBS)",
      "endif",
      "ifeq ($(BUILDTYPE), EXE)",
      "\t$(CXX) -o $(TARGET) $(OBJECTS) $(LINKDIRS) $(STATIC_LINK_FLAG) $(SLINKS) $(DYNAMIC_LINK_FLAG) $(DLINKS) $(AS_NEED_LINK_FLAG) $(RPATH_LINK_FLAG)",
      "else ifeq ($(BUILDTYPE), STATICLIB)",
      "\t$(AR) -rcs $(TARGET) $(OBJECTS)",
      "else ifeq ($(BUILDTYPE), DYNAMICLIB)",
      "\t$(CXX) -shared -o $(TARGET) $(OBJECTS) $(LINKDIRS) $(STATIC_LINK_FLAG) $(SLINKS) $(DYNAMIC_LINK_FLAG) $(DLINKS) $(AS_NEED_LINK_FLAG) $(INSTALL_NAME_FLAG)",
      "endif",
      "\t@echo built $(TARGET)",
      "",
      "# Copy Dynamic Libraries",
      "ifeq ($(BUILDTYPE),EXE)",
      "$(TARGET): | $(OUT_DLIBS)",
      "$(OUT_DLIBS): $(TARGETDIR)/% : % | $(TARGETDIR)",
      "\t$(call cp, $<, $(TARGETDIR))",
      "endif",
      "",
      "compile: $(OBJECTS)",
      "build: $(TARGET)",
      "\t$(POSTBUILDCMDS)",
      "dirs: $(OBJDIR) $(TARGETDIR)",
      "",
      "clean: ",
      "\t@echo clean",
      "ifneq ($(wildcard $(OBJCLEANDIR)),)",
      "ifeq ($(FILESYS),Windows)",
      "\trmdir /s /q $(subst /,\\,$(OBJCLEANDIR))",
      "else ifeq ($(FILESYS), Linux)",
      "\trmdir /s /q $(OBJCLEANDIR)",
      "else ifeq ($(FILESYS), OSX)",
      "\trm -r $(OBJCLEANDIR)",
      "endif",
      "endif",
      "ifneq ($(wildcard $(TARGETCLEANDIR)),)",
      "ifeq ($(FILESYS),Windows)",
      "\trmdir /s /q $(subst /,\\,$(TARGETCLEANDIR))",
      "else ifeq ($(FILESYS), Linux)",
      "\trmdir /s /q $(TARGETCLEANDIR)",
      "else ifeq ($(FILESYS), OSX)",
      "\trm -r $(TARGETCLEANDIR)",
      "endif",
      "endif",
      "\t@echo cleaned",
      "",
      "-include $(OBJECTS:%.o=%.d)"
    },
  }),
  s("makefile", {
    t{
      "# makefile",
      ".PHONY: all clean dirs $(MAKES) $(CLEANS) $(DIRS)",
      "",
      "export CXX = g++",
      "export AR = ar",
      "ifeq ($(CXX_VERSION),)",
      "CXX_VERSION=c++23",
      "endif",
      "export CXXFLAGS = -std=$(CXX_VERSION)",
      "ifeq ($(SYS),)",
      "SYS = Linux",
      "endif",
      "export SYS",
      "ifeq ($(FILESYS),)",
      "FILESYS = $(SYS)",
      "endif",
      "export FILESYS",
      "",
      "#? List of submakes ex. # ./make/submake1.mk",
      "PROJECTS = \\",
      "",
      "#? List of TARGET_PATHs to be created first. (Only useful if running `make -j` and there are shared TARGET_PATHs) ex. # ./make/submake1.mk",
      "PROJECTDIRS = \\",
      "",
      "DIRS = $(foreach PROJECTDIR, $(PROJECTDIRS), d$(PROJECTDIR))",
      "MAKES = $(foreach PROJECT, $(PROJECTS), m$(PROJECT))",
      "CLEANS = $(foreach PROJECT, $(PROJECTS), c$(PROJECT))",
      "",
      "all: $(MAKES)",
      "clean: $(CLEANS)",
      "dirs: $(DIRS)",
      "",
      "#? Submake dependencies (allows `make -j` to work) ex. # m./make/submake1.mk: m./make/submake2.mk",
      "#? A submake depends on another if it uses the target of the other (such as the form of a library)",
      "",
      "# Static pattern rules for running sub-makes",
      "$(DIRS): d%: %",
      "\t@$(MAKE) --no-print-directory -f $< dirs",
      "",
      "$(MAKES): m%: % $(DIRS)",
      "\t@$(MAKE) --no-print-directory -f $<",
      "",
      "$(CLEANS): c%: %",
      "\t@$(MAKE) --no-print-directory -f $< clean"
    }
  })
})
