local ls = require("luasnip")
local s = ls.snippet
-- local sn = ls.snippet_node
-- local isn = ls.indent_snippet_node
local t = ls.text_node
local i = ls.insert_node

ls.add_snippets("make", {
  s("make_vars",{
    t"# ", i(1),
    t{"",
      "",
      "#? Variables",
      "# STATICLIB, DYNAMICLIB, or EXE # (no space after)",
      "BUILDTYPE = "}, i(2),
    t{"",
      "# COMPILEONLY, LINKONLY, or BOTH # (no space after)",
      "PROCESS = "}, i(3),
    t{"",
      "TARGET_NAME = "}, i(4),
    t{"",
      "# <path-to-dir>",
      "TARGET_PATH = "}, i(5),
    t{"",
      "# Include Directories # -I<path-to-dir>",
      "INCLUDES = \\"}, i(6),
    t{"",
      "# Link Directories # -L<path-to-dir>",
      "LINKDIRS = \\"}, i(7),
    t{"",
      "# if on linux or windows, for linking libraries `-l<file>` do not prepend `lib` to the link flag (unless its in the file name) as each `-l` is converted into `-l:` in maker.mk",
      "# if on osx, use -l (internal lib) syntax only, every lib file must begin with `lib`. if lib is static, it must end in `.a`, else if lib dynamic, it must end in `.dylib`",
      "# Dynamic link files # (for internal libs) `-l<file-no-extension>` or (for external libs) `-l:<file-w-extension>` # Order from most dependent to least dependent.",
      "DLINKS = \\"}, i(8),
    t{"",
      "# Static link files # (for internal libs) `-l<file-no-extension>` or (for external libs) `-l:<file-w-extension>` # Order from most dependent to least dependent.",
      "SLINKS = \\"}, i(9),
    t{"",
      "DEFINES = "}, i(9),
    t{"",
      "SRCDIRS = \\"}, i(10),
    t{"",
      "SRCFILES = \\"}, i(11),
    t{"",
      "",
      "#? Constants",
      "OBJDIR = bin/$(TARGET_PATH)",
      "TARGETDIR = build/$(TARGET_PATH)",
      "OBJCLEANDIR = $(OBJDIR)",
      "TARGETCLEANDIR = $(TARGETDIR)"},
    t{"",
      "",
      "#? Custom build cmds",
      "define POSTBUILDCMDS",
      "endef",
      "",
      "include ./make/maker.mk"},
  }),
  s("make_maker",{
    t{
      "# maker.mk",
      ".PHONY: all compile build dirs clean",
      "",
      "#* Make functions",
      "# eq uses makefile substitution reference",
      "define eq",
      "$(if $(1:$(2)=),,$(if $(2:$(1)=),,T))",
      "endef",
      "",
      "#* Compiler flags",
      "CXXFLAGS += $(CPPFLAGS) -MD -MP -g",
      "ifeq ($(SYS), Windows)",
      "SLINK_TYPE = lib",
      "DLINK_TYPE = dll",
      "EXE_TYPE = .exe",
      "else ifeq ($(filter-out Linux OSX, $(SYS)),)",
      "SLINK_TYPE = a",
      "DLINK_TYPE = so",
      "EXE_TYPE =",
      "endif",
      "ifeq ($(SYS),OSX)",
      "STATIC_LINK_FLAG=",
      "DYNAMIC_LINK_FLAG=",
      "AS_NEED_LINK_FLAG=",
      "else ifeq ($(filter-out Linux Windows, $(SYS)),)",
      "STATIC_LINK_FLAG=-Wl,-Bstatic",
      "DYNAMIC_LINK_FLAG=-Wl,-Bdynamic",
      "AS_NEED_LINK_FLAG=-Wl,--as-needed",
      "endif",
      "ifneq ($(SYS),OSX)",
      "SLINK_FILES := $(patsubst -l%, %.$(SLINK_TYPE), $(patsubst -l:%, %, $(SLINKS)))",
      "DLINK_FILES := $(patsubst -l%, %.$(DLINK_TYPE), $(patsubst -l:%, %, $(DLINKS)))",
      "SLINKS = $(patsubst %, -l:%, $(SLINK_FILES))",
      "DLINKS = $(patsubst %, -l:%, $(DLINK_FILES))",
      "else",
      "SLINK_FILES := $(patsubst -l%, %, $(patsubst -l:%.*, %, $(SLINKS)))",
      "DLINK_FILES := $(patsubst -l%, %, $(patsubst -l:%.*, %, $(DLINKS)))",
      "SLINKS = $(patsubst %, -l%, $(SLINK_FILES))",
      "DLINKS = $(patsubst %, -l%, $(DLINK_FILES))",
      "endif",
      "",
      "LINKS = $(SLINK_FILES) $(DLINK_FILES)",
      "",
      "#* First class functions",
      "find_srcs = $(wildcard $(addprefix $(addsuffix /, $(SRCDIR)), $(SRCFILES)))",
      "find_libs = $(wildcard $(addprefix $(addsuffix /, $(LINKDIR)), $(LINKS)))",
      "list_rm = $(wordlist 2, $(words $1), $1)",
      "pairmap = $(and $(strip $2), $(strip $3), $(call $1, $(firstword $2), $(firstword $3)) $(call pairmap, $1, $(call list_rm, $2), $(call list_rm, $3)))",
      "compile_exe_cmd = $(shell $(CXX) $(INCLUDES) -c$1 -o$2 $(CXXFLAGS) -MF$(2:%.o=%.d))",
      "compile_lib_cmd = $(shell $(CXX) -fPIC $(INCLUDES) -c$1 -o$2 $(CXXFLAGS) -MF$(2:%.o=%.d))",
      "",
      "#* Constants",
      "SRCS = $(foreach SRCDIR, $(SRCDIRS), $(find_srcs))",
      "LIBS = $(foreach LINKDIR, $(patsubst -L%, %, $(LINKDIRS)), $(find_libs))",
      "OBJECTS = $(addprefix $(OBJDIR)/, $(patsubst %.cpp, %.o, $(SRCFILES)))",
      "# If SYS == OSX and BUILDTYPE == (STATICLIB or DYNAMICLIB)",
      "ifneq ($(and $(call eq,$(SYS),OSX), $(call eq,$(filter-out STATICLIB DYNAMICLIB, $(BUILDTYPE)),)),)",
      "TARGET = $(TARGETDIR/lib$(TARGET_NAME))",
      "else",
      "TARGET = $(TARGETDIR)/$(TARGET_NAME)",
      "endif",
      "ifeq ($(BUILDTYPE), EXE)",
      "TARGET := $(TARGET)$(EXE_TYPE)",
      "else ifeq ($(BUILDTYPE), STATICLIB)",
      "TARGET := $(TARGET).$(SLINK_TYPE)",
      "else ifeq ($(BUILDTYPE), DYNAMICLIB)",
      "TARGET := $(TARGET).$(DLINK_TYPE)",
      "endif",
      "",
      "#* Process execution",
      "ifeq ($(filter-out BOTH LINKONLY, $(PROCESS)),)",
      "all: $(TARGET)",
      "\t$(POSTBUILDCMDS)",
      "else ifeq ($(PROCESS), COMPILEONLY)",
      "all: $(OBJECTS)",
      "else",
      "all:",
      "\t@echo error: invalid process",
      "endif",
      "",
      "# Create bin directory",
      "$(OBJDIR):",
      "ifeq ($(wildcard $(OBJDIR)),)",
      "ifeq ($(SYS),Windows)",
      "\t@mkdir $(subst /,\\\\,$(OBJDIR))",
      "else ifeq ($(filter-out Linux OSX, $(SYS)),)",
      "\t@mkdir -p $(OBJDIR)",
      "endif",
      "\t@echo create bin directory",
      "endif",
      "",
      "# Compile sources into objects",
      "$(OBJECTS): $(SRCS) | $(OBJDIR)",
      "\t@echo compile",
      "ifeq ($(BUILDTYPE), EXE)",
      "\t$(call pairmap, compile_exe_cmd, $(SRCS), $(OBJECTS))",
      "else ifeq ($(filter-out STATICLIB DYNAMICLIB, $(BUILDTYPE)),)",
      "\t$(call pairmap, compile_lib_cmd, $(SRCS), $(OBJECTS))",
      "else",
      "\t@echo invalid buildtype",
      "endif",
      "\t@echo compiled",
      "",
      "# Create build directory",
      "$(TARGETDIR):",
      "ifeq ($(wildcard $(TARGETDIR)),)",
      "ifeq ($(SYS),Windows)",
      "\t@mkdir $(subst /,\\\\,$(TARGETDIR))",
      "else ifeq ($(filter-out Linux OSX, $(SYS)),)",
      "\t@mkdir -p $(TARGETDIR)",
      "endif",
      "\t@echo create build directory",
      "endif",
      "",
      "# Build target from objects",
      "ifeq ($(PROCESS), LINKONLY)",
      "$(TARGET): $(LIBS) | $(TARGETDIR)",
      "else",
      "$(TARGET): $(OBJECTS) $(LIBS) | $(TARGETDIR)",
      "endif",
      "\t@echo build",
      "ifeq ($(BUILDTYPE), EXE)",
      "\t$(CXX) $(OBJECTS) $(LINKDIRS) $(STATIC_LINK_FLAG) $(SLINKS) $(DYNAMIC_LINK_FLAG) $(DLINKS) $(AS_NEED_LINK_FLAG) -o $(TARGET)",
      "else ifeq ($(BUILDTYPE), STATICLIB)",
      "\t$(AR) -rcs $(TARGET) $(OBJECTS)",
      "else ifeq ($(BUILDTYPE), DYNAMICLIB)",
      "\t$(CXX) -shared -o $(TARGET) $(OBJECTS) $(LINKDIRS) $(STATIC_LINK_FLAG) $(SLINKS) $(DYNAMIC_LINK_FLAG) $(DLINKS) $(AS_NEED_LINK_FLAG)",
      "endif",
      "\t@echo built",
      "",
      "compile: $(OBJECTS)",
      "build: $(TARGET)",
      "\t$(POSTBUILDCMDS)",
      "dirs: $(OBJDIR) $(TARGETDIR)",
      "",
      "clean: ",
      "\t@echo clean",
      "ifneq ($(wildcard $(OBJCLEANDIR)),)",
      "ifeq ($(SYS),Windows)",
      "\trmdir /s /q $(subst /,\\\\,$(OBJCLEANDIR))",
      "else ifeq ($(SYS), Linux)",
      "\trmdir /s /q $(OBJCLEANDIR)",
      "else ifeq ($(SYS), OSX)",
      "\trm -r $(OBJCLEANDIR)",
      "endif",
      "endif",
      "ifneq ($(wildcard $(TARGETCLEANDIR)),)",
      "ifeq ($(SYS),Windows)",
      "\trmdir /s /q $(subst /,\\\\,$(TARGETCLEANDIR))",
      "else ifeq ($(SYS), Linux)",
      "\trmdir /s /q $(TARGETCLEANDIR)",
      "else ifeq ($(SYS), OSX)",
      "\trm -r $(TARGETCLEANDIR)",
      "endif",
      "endif",
      "\t@echo cleaned",
      "",
      "-include $(OBJECTS:%.o=%.d)"
    },
  }),
  s("makefile", {
    t{
      "# makefile",
      ".PHONY: all clean $(MAKES) $(CLEANS) $(DIRS)",
      "",
      "export CXX = g++",
      "export AR = ar",
      "ifeq ($(CXX_VERSION),)",
      "CXX_VERSION=c++23",
      "endif",
      "export CXXFLAGS = -std=$(CXX_VERSION)",
      "ifeq ($(SYS),)",
      "SYS = Linux",
      "endif",
      "export SYS",
      "",
      "#? List of submakes ex. # ./make/submake1.mk",
      "PROJECTS = \\",
      "",
      "#? List of TARGET_PATHs to be created first. (Only useful if running `make -j` and there are shared TARGET_PATHs) ex. # ./make/submake1.mk",
      "PROJECTDIRS = \\",
      "",
      "DIRS = $(foreach PROJECTDIR, $(PROJECTDIRS), d$(PROJECTDIR))",
      "MAKES = $(foreach PROJECT, $(PROJECTS), m$(PROJECT))",
      "CLEANS = $(foreach PROJECT, $(PROJECTS), c$(PROJECT))",
      "",
      "all: $(MAKES)",
      "clean: $(CLEANS)",
      "dirs: $(DIRS)",
      "",
      "#? Submake dependencies (allows `make -j` to work) ex. # m./make/submake1.mk: m./make/submake2.mk",
      "#? A submake depends on another if it uses the target of the other (such as the form of a library)",
      "",
      "# Static pattern rules for running sub-makes",
      "$(DIRS): d%: %",
      "\t@$(MAKE) --no-print-directory -f $< dirs",
      "",
      "$(MAKES): m%: % $(DIRS)",
      "\t@$(MAKE) --no-print-directory -f $<",
      "",
      "$(CLEANS): c%: %",
      "\t@$(MAKE) --no-print-directory -f $< clean"
    }
  })
})
