local ls = require("luasnip")
local s = ls.snippet
-- local sn = ls.snippet_node
-- local isn = ls.indent_snippet_node
local t = ls.text_node
local i = ls.insert_node

ls.add_snippets("make", {
  s("make_vars",{
    t"# ", i(1),
    t{"",
      "",
      "#? Variables",
      "# STATICLIB, DYNAMICLIB, or EXE # (no space after)",
      "BUILDTYPE = "}, i(2),
    t{"",
      "# COMPILEONLY, LINKONLY, or BOTH # (no space after)",
      "PROCESS = "}, i(3),
    t{"",
      "TARGET_NAME = "}, i(4),
    t{"",
      "# <path-to-dir>",
      "TARGET_PATH = "}, i(5),
    t{"",
      "# Include Directories # -I<path-to-dir>",
      "INCLUDES = \\"}, i(6),
    t{"",
      "# Link Directories # -L<path-to-dir>",
      "LINKDIRS = \\"}, i(7),
    t{"",
      "# Dynamic link files # -l<file-no-extension> or -l:<file-w-extension> # Order from most dependent to least dependent.",
      "DLINKS = \\"}, i(8),
    t{"",
      "# Static link files # -l<file-no-extension> or -l:<file-w-extension> # Order from most dependent to least dependent.",
      "SLINKS = \\"}, i(9),
    t{"",
      "DEFINES = "}, i(9),
    t{"",
      "SRCDIRS = \\"}, i(10),
    t{"",
      "SRCFILES = \\"}, i(11),
    t{"",
      "",
      "#? Constants",
      "OBJDIR = bin/$(TARGET_PATH)",
      "TARGETDIR = build/$(TARGET_PATH)",
      "OBJCLEANDIR = $(OBJDIR)",
      "TARGETCLEANDIR = $(TARGETDIR)"},
    t{"",
      "",
      "#? Custom build cmds",
      "define POSTBUILDCMDS",
      "endef",
      "",
      "include ./make/maker.mk"},
  }),
  s("make_maker",{
    t{
      "# maker.mk",
      ".PHONY: all compile build dirs clean",
      "",
      "#* Compiler flags",
      "CXXFLAGS += $(CPPFLAGS) -MD -MP -g",
      "#* Pre-constants",
      "SLINK_FILES = $(patsubst -l%, %.lib, $(patsubst -l:%, %, $(SLINKS)))",
      "DLINK_FILES = $(patsubst -l%, %.dll, $(patsubst -l:%, %, $(DLINKS)))",
      "LINKS = $(SLINK_FILES) $(DLINK_FILES)",
      "",
      "#* First class functions",
      "find_srcs = $(wildcard $(addprefix $(addsuffix /, $(SRCDIR)), $(SRCFILES)))",
      "find_libs = $(wildcard $(addprefix $(addsuffix /, $(LINKDIR)), $(LINKS)))",
      "list_rm = $(wordlist 2, $(words $1), $1)",
      "pairmap = $(and $(strip $2), $(strip $3), $(call $1, $(firstword $2), $(firstword $3)) $(call pairmap, $1, $(call list_rm, $2), $(call list_rm, $3)))",
      "compile_exe_cmd = $(shell $(CXX) $(INCLUDES) -c$1 -o$2 $(CXXFLAGS) -MF$(2:%.o=%.d))",
      "compile_lib_cmd = $(shell $(CXX) -fPIC $(INCLUDES) -c$1 -o$2 $(CXXFLAGS) -MF$(2:%.o=%.d))",
      "",
      "#* Constants",
      "ifeq ($(OS),Windows_NT)",
      "SYS = Windows",
      "else ifeq ($(shell uname -s),Linux)",
      "SYS = Linux",
      "else ifeq ($(shell uname -s),Darwin)",
      "SYS = OSX",
      "endif",
      "SRCS = $(foreach SRCDIR, $(SRCDIRS), $(find_srcs))",
      "LIBS = $(foreach LINKDIR, $(patsubst -L%, %, $(LINKDIRS)), $(find_libs))",
      "OBJECTS = $(addprefix $(OBJDIR)/, $(patsubst %.cpp, %.o, $(SRCFILES)))",
      "TARGET = $(TARGETDIR)/$(TARGET_NAME)",
      "ifeq ($(BUILDTYPE), EXE)",
      "TARGET := $(TARGET).exe",
      "else ifeq ($(BUILDTYPE), STATICLIB)",
      "TARGET := $(TARGET).lib",
      "else ifeq ($(BUILDTYPE), DYNAMICLIB)",
      "TARGET := $(TARGET).dll",
      "endif",
      "",
      "#* Process execution",
      "ifneq ($(filter $(PROCESS), BOTH LINKONLY),)",
      "all: $(TARGET)",
      "\t$(POSTBUILDCMDS)",
      "else ifeq ($(PROCESS), COMPILEONLY)",
      "all: $(OBJECTS)",
      "else",
      "all:",
      "\t@echo error: invalid process",
      "endif",
      "",
      "# Create bin directory",
      "$(OBJDIR):",
      "ifeq ($(wildcard $(OBJDIR)),)",
      "ifeq ($(SYS),Windows)",
      "\t@mkdir $(subst /,\\\\,$(OBJDIR))",
      "else ifneq ($(filter $(SYS), Linux OSX),)",
      "\t@mkdir -p $(OBJDIR)",
      "endif",
      "\t@echo create bin directory",
      "endif",
      "",
      "# Compile sources into objects",
      "$(OBJECTS): $(SRCS) | $(OBJDIR)",
      "\t@echo compile",
      "ifeq ($(BUILDTYPE), EXE)",
      "\t$(call pairmap, compile_exe_cmd, $(SRCS), $(OBJECTS))",
      "else ifneq ($(filter $(BUILDTYPE), STATICLIB DYNAMICLIB),)",
      "\t$(call pairmap, compile_lib_cmd, $(SRCS), $(OBJECTS))",
      "else",
      "\t@echo invalid buildtype",
      "endif",
      "\t@echo compiled",
      "",
      "# Create build directory",
      "$(TARGETDIR):",
      "ifeq ($(wildcard $(TARGETDIR)),)",
      "ifeq ($(SYS),Windows)",
      "\t@mkdir $(subst /,\\\\,$(TARGETDIR))",
      "else ifneq ($(filter $(SYS), Linux OSX),)",
      "\t@mkdir -p $(TARGETDIR)",
      "endif",
      "\t@echo create build directory",
      "endif",
      "",
      "# Build target from objects",
      "ifeq ($(PROCESS), LINKONLY)",
      "$(TARGET): | $(TARGETDIR)",
      "else",
      "$(TARGET): $(OBJECTS) $(LIBS) | $(TARGETDIR)",
      "endif",
      "\t@echo build",
      "ifeq ($(BUILDTYPE), EXE)",
      "\t$(CXX) $(OBJECTS) $(LINKDIRS) -Wl,-Bstatic $(SLINKS) -Wl,-Bdynamic $(DLINKS) -Wl,--as-needed -o $(TARGET)",
      "else ifeq ($(BUILDTYPE), STATICLIB)",
      "\t$(AR) -rcs $(TARGET) $(OBJECTS)",
      "else ifeq ($(BUILDTYPE), DYNAMICLIB)",
      "\t$(CXX) -shared -o $(TARGET) $(OBJECTS) $(LINKDIRS) -Wl,-Bstatic $(SLINKS) -Wl,-Bdynamic $(DLINKS) -Wl,--as-needed",
      "endif",
      "\t@echo built",
      "",
      "compile: $(OBJECTS)",
      "build: $(TARGET)",
      "\t$(POSTBUILDCMDS)",
      "dirs: $(OBJDIR) $(TARGETDIR)",
      "",
      "clean: ",
      "\t@echo clean",
      "ifneq ($(wildcard $(OBJCLEANDIR)),)",
      "ifeq ($(SYS),Windows)",
      "\trmdir /s /q $(subst /,\\\\,$(OBJCLEANDIR))",
      "else ifneq ($(filter $(SYS), Linux OSX),)",
      "\trmdir /s /q $(OBJCLEANDIR)",
      "endif",
      "endif",
      "ifneq ($(wildcard $(TARGETCLEANDIR)),)",
      "ifeq ($(SYS),Windows)",
      "\trmdir /s /q $(subst /,\\\\,$(TARGETCLEANDIR))",
      "else ifneq ($(filter $(SYS), Linux OSX),)",
      "\trmdir /s /q $(TARGETCLEANDIR)",
      "endif",
      "endif",
      "\t@echo cleaned",
      "",
      "-include $(OBJECTS:%.o=%.d)"
    },
  }),
  s("makefile", {
    t{
      "# makefile",
      ".PHONY: all clean $(MAKES) $(CLEANS) $(DIRS)",
      "",
      "export CXX = g++",
      "export AR = ar",
      "",
      "#? List of submakes ex. # ./make/submake1.mk",
      "PROJECTS = \\",
      "",
      "#? List of TARGET_PATHs to be created first. (Only useful if running `make -j` and there are shared TARGET_PATHs) # ./make/submake1.mk",
      "PROJECTDIRS = \\",
      "",
      "DIRS = $(foreach PROJECTDIR, $(PROJECTDIRS), d$(PROJECTDIR))",
      "MAKES = $(foreach PROJECT, $(PROJECTS), m$(PROJECT))",
      "CLEANS = $(foreach PROJECT, $(PROJECTS), c$(PROJECT))",
      "",
      "all: $(MAKES)",
      "clean: $(CLEANS)",
      "",
      "#? Submake dependencies (allows `make -j` to work) ex. # m./make/submake1.mk: m./make/submake2.mk",
      "#? A submake depends on another if it uses the target of the other (such as the form of a library)",
      "",
      "# Static pattern rules for running sub-makes",
      "$(DIRS): d%: %",
      "\t@$(MAKE) --no-print-directory -f $< dirs",
      "",
      "$(MAKES): m%: % $(DIRS)",
      "\t@$(MAKE) --no-print-directory -f $<",
      "",
      "$(CLEANS): c%: %",
      "\t@$(MAKE) --no-print-directory -f $< clean"
    }
  })
})
